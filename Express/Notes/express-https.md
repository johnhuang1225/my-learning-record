## HTTPS

The first step in providing secure services is using HTTP Secure (HTTPS). The nature of the Internet makes it possible for a third party to intercept packets being transmitted between clients and servers. HTTPS encrypts those packets, making it extremely difficult for an attacker to get access to the information being transmitted.

You can think of HTTPS as sort of a foundation for securing your website. It does not provide authentication, but it lays the groundwork for authentication. For example, your authentication system probably involves transmitting a password: if that password is transmitted unencrypted, no amount of authentication sophistication will secure your system. Security is as strong as the weakest link, and the first link in that chain is the network protocol.

The HTTPS protocol is based on the server having a **public key certificate**, sometimes called an SSL certificate. The current standard format for SSL certificates is called X. 509. The idea behind certificates is that there are certificate authorities (CAs) that issue certificates. A certificate authority makes trusted root certificates available to browser vendors. Browsers include these trusted root certificates when you install a browser, and that’s what establishes the chain of trust between the CA and the browser. For this chain to work, your server must use a certificate issued by a CA.

The upshot of this is that to provide HTTPS, you need a certificate from a CA, so how does one go about acquiring such a thing? Broadly speaking, you can generate your own, get one from a free CA, or purchase one from a commercial CA.

#### Generating Your Own Certificate

Generating your own certificate is easy, but generally suitable only for development and testing purposes (and possibly for intranet deployment). Due to the hierarchical nature established by certificate authorities, browsers will trust only certificates generated by a known CA (and that’s probably not you). If your website uses a certificate from a CA that’s not known to the browser, the browser will warn you in very alarming language that you’re establishing a secure connection with an unknown (and therefore untrusted) entity. In development and testing, this is fine: you and your team know that you gen‐ erated your own certificate, and you expect this behavior from browsers. If you were to deploy such a website to production for consumption by the public, they would turn away in droves.

To generate your own certificate, you’ll need an OpenSSL implementation.

```
brew install openssl
```

Once you’ve installed OpenSSL, you can generate a private key and a public certificate:

```
openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout meadowlark.pem -out meadowlark.crt
```

If you’re curious about the details of this command, you can read about them on the [OpenSSL documentation page](http://www.openssl.org/docs/apps/req.html). It is worth pointing out that the -nodes option doesn’t have anything to do with Node, or even the plural word “nodes”: it actually means “no DES,” meaning the private key is not DES-encrypted.

The result of this command is two files, `meadowlark.pem` and `meadowlark.crt`. The PEM (Privacy-enhanced Electronic Mail) file is your private key, and should not be made available to the client. The CRT file is the self-signed certificate that will be sent to the browser to establish a secure connection.

#### Enabling HTTPS for Your Express App

Once you have your private key and certificate, using them in your app is easy.

Switching over to HTTPS is simple. I recommend that you put your private key and SSL cert in a subdirectory called `ssl` (though it’s quite common to keep it in your project root). Then you just use the https module instead of http, and pass an options object along to the createServer method:

```js
var https = require('https'); // usually at top of file

var options = {
  key: fs.readFileSync(__dirname + '/ssl/meadowlark.pem');
  cert: fs.readFileSync(__dirname + '/ssl/meadowlark.crt');
};

https.createServer(options, app).listen(app.get('port'), function(){
  console.log('Express started in ' + app.get('env') + ' mode on port ' + app.get('port') + '.');
});
```

That’s all there is to it. Assuming you’re still running your server on port 3000, you can now connect to https://localhost:3000. If you try to connect to http://localhost:3000, it will simply time out.
